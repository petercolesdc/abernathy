
// Typography specific mixins
// ------------------------------------------------------------------

// Make pixel values into REMS
@function rem($pixels){
	@return $pixels / $scaleRoot + rem; // Usage = font-size: rem(xx);
}

// Tweak leading
@mixin leading_adjust($gapAdjust) {
	line-height: $lineheightBase - ($gapAdjust/$scaleRoot);
}

// Basline spacing with regular units
@mixin baseline($baselineMult, $type) {
	@if $type == "margin-bottom"  {
		margin-bottom: rem($gridBaseline*$baselineMult);
	} @else if $type == "margin-top"  {
		margin-top: rem($gridBaseline*$baselineMult);
	} @else if $type == "padding-bottom"  {
		padding-bottom: rem($gridBaseline*$baselineMult);
	} @else if $type == "padding-top"  {
		padding-top: rem($gridBaseline*$baselineMult);
	} @else {

	}
}

// Grid calculations
// ------------------------------------------------------------------

// gridCalc
// $GgridGap = The gap between grid items (default to 0)
// Used to set a grid only.
@mixin gridCalc($GgridGap: 'false') {
	display: grid;
	grid-template-columns: $gridCols;
	@if $GgridGap == 'true'  {
		grid-gap: $gridGap;
	} @else {
		grid-gap: 0;
	}
}

// gridCol
// In combination with gridCalc this detemines the start point & span of columns
@mixin gridCol($gridStart, $gridSpan) {
	grid-column: $gridStart / span $gridSpan;
}

// gridRow
// In combination with gridCalc this detemines the start point & span of rows
@mixin gridRow($gridStart, $gridSpan) {
	grid-row: $gridStart / span $gridSpan;
}

// gridRepeat
// This should only be used for grids with the same width of columns that repeat

@mixin gridRepeat($colNumber, $GgridGap: $gridGap, $GgridRowGap: $gridRowGap) {
  display: grid;
  grid-template-columns: repeat($colNumber, 1fr);
  grid-gap: $GgridGap;
  grid-row-gap: $gridRowGap
}


// Link interaction combo
// Bundle hover, focus and active together
// Overide as needed
// ------------------------------------------------------------------

@mixin link-active-styles {
	&:hover, &:focus, &:active {
		@content;
	}
}

// Media queries
// Simplify the syntax and use variables for easy changes
// ------------------------------------------------------------------


// Widths only
@mixin respond-to($media-min) {
	@media screen and (min-width: $media-min) {
	    @content;
	}
}

@mixin respond-to-max($media-max) {
	@media screen and (max-width: $media-max - 1px) {
	    @content;
	}
}

@mixin respond-to-min-max($media-min, $media-max) {
	 @media screen and (min-width: $media-min) and (max-width: $media-max - 1px) {
	    @content;
	}
}

// Widths and heights
@mixin respond-to-both($media-w-min, $media-h-min) {
	@media screen and (min-width: $media-w-min) and (min-height: $media-h-min) {
	    @content;
	}
}

// Height only
@mixin respond-to-height($media-min) {
	@media screen and (min-height: $media-min) {
	    @content;
	}
}

@mixin respond-to-height-max($media-max) {
	@media screen and (max-height: $media-max - 1px) {
	    @content;
	}
}

// Both
@mixin respond-to-both-max-min($media-w-min, $media-h-min) {
	@media screen and (max-width: $media-w-min) and (min-height: $media-h-min - 1px) {
	    @content;
	}
}

// A11y hidden
// Hide things on the page in an accessible way (eg form labels)
// ------------------------------------------------------------------

@mixin a11yhide {
	position: absolute !important;
	clip: rect(1px, 1px, 1px, 1px);
	padding: 0px;
	border: 0 !important;
	height: 1px !important;
	width: 1px !important;
	overflow: hidden;
}

// Ratios
// Use maths to make responsive ratios (works great for video embeds)
// ------------------------------------------------------------------

@mixin ratio($ratio: 1 1) {
	//@if length($ratio) < 2 or length($ratio) > 2 { @warn "$ratio must be a list with two values."; }
	$ratio-width: 100%;
	$ratio-height: percentage(nth($ratio, 2) / nth($ratio, 1));
	width: $ratio-width;
	height: 0;
	padding-bottom: $ratio-height;
}


// Animation
// ------------------------------------------------------------------

// HACKS - https://github.com/IanLunn/Hover/blob/master/scss/_hacks.scss
// As is often the case, some devices/browsers need additional code to get CSS to work
// in the most desired way. These mixins are used to quickly drop in hacks for each element
// Find out more here: https://github.com/IanLunn/Hover/wiki/Hacks-Explained

@mixin hardwareAccel() {
	// Improve performance on mobile/tablet devices
	// Perspective reduces blurryness of text in Chrome
	transform: perspective(1px) translateZ(0);
}

@mixin improveAntiAlias() {
	// Improve aliasing on mobile/tablet devices
	box-shadow: 0 0 1px rgba(0, 0, 0, 0);
}

@mixin forceBlockLevel() {
	// Transforms need to be block-level to work
	display: inline-block;
	vertical-align: middle;
}

@mixin animationHacks() {
	@include forceBlockLevel();
	@include hardwareAccel();
	@include improveAntiAlias();
}

// Clearfix - Old Skool
// ------------------------------------------------------------------

@mixin pie-clearfix {
	&:after {
		content: "";
		display: table;
		clear: both;
    //*zoom: 1;
	}
}

// Sharpen type (use with care)
// ------------------------------------------------------------------

@mixin sharp-text {
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
	//text-rendering: optimizeLegibility;
}


// Faux links
// ------------------------------------------------------------------

@mixin fauxUnderline($color) {
  background-image: linear-gradient(
    to top,
    rgba($color, 0) 3%,
    rgba($color, 0.7) 3%,
    rgba($color, 0.7) 20%,
    rgba($color, 0) 20%
  );
}

// ------------------------------------------------------------------

// LEGACY

// ------------------------------------------------------------------


// Shadow controls
// ------------------------------------------------------------------

@mixin shadowSubtle {
  box-shadow: 0 1px 1px 0 rgba(0,0,0,0.075), 0 2px 1px 0 rgba(0,0,0,0.05);
}


// Consistent edges
// ------------------------------------------------------------------

@mixin edgeBufferLeft($type) {
  @if $type == "padding" {
    padding-left: $edges;
		@include respond-to($vpRowBufferA) {
  		padding-left: 0;
  	}
  } @else {
    left: $edges;
  	@include respond-to($vpRowBufferA) {
  		left: 0;
  	}
  }
}

@mixin edgeBufferRight($type) {
  @if $type == "padding" {
    padding-right: $edges;
		@include respond-to($vpRowBufferA) {
  		padding-right: 0;
  	}
  } @else {
    right: $edges;
  	@include respond-to($vpRowBufferA) {
  		right: 0;
  	}
  }
}

@mixin edgeBufferTop($type) {
  @if $type == "padding" {
    padding-top: $edges;
  } @else {
    margin-top: $edges;
  }
}

@mixin edgeBufferBottom($type) {
  @if $type == "padding" {
    padding-bottom: $edges;
  } @else {
    margin-bottom: $edges;
  }
}
